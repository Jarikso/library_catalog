# Book Library API

Это FastAPI-приложение для управления библиотекой книг с поддержкой различных хранилищ данных: базы данных PostgreSQL, файлов JSON и сервиса JsonBin.io.

## Возможности

- CRUD операции для книг (создание, чтение, обновление, удаление)
- Интеграция с OpenLibrary API для автоматического дополнения информации о книгах
- Поддержка нескольких хранилищ данных:
  - PostgreSQL (асинхронный доступ)
  - Локальные JSON-файлы
  - Облачное хранилище JsonBin.io
- Логирование всех операций
- Обработка ошибок и валидация данных
- Документация API через Swagger UI

## Технологии

- Python 3.10+
- FastAPI
- SQLAlchemy (асинхронный режим)
- Pydantic (валидация данных)
- Aiohttp (HTTP-клиент)
- Logging (логирование)
- Docker (опционально)

## Установка и запуск

1. Установите зависимости:
   ```bash
   pip install -r requirements.txt
   ```

2. Запустите приложение:
   ```bash
   uvicorn main:app --reload
   ```

   Приложение будет доступно по адресу: `http://localhost:8000`

## Использование API

Документация API доступна через Swagger UI: `http://localhost:8000/docs`

### Доступные эндпоинты:

#### База данных (PostgreSQL)
- `POST /db/` - Создать книгу
- `GET /db/` - Получить список книг
- `GET /db/{book_id}` - Получить книгу по ID
- `PUT /db/{book_id}` - Обновить книгу
- `DELETE /db/{book_id}` - Удалить книгу

#### Файловое хранилище (JSON)
- `POST /file/` - Создать книгу
- `GET /file/` - Получить список книг
- `GET /file/{book_id}` - Получить книгу по ID
- `PUT /file/{book_id}` - Обновить книгу
- `DELETE /file/{book_id}` - Удалить книгу

#### JsonBin.io
- `POST /jsonbin/` - Создать книгу
- `GET /jsonbin/` - Получить список книг
- `GET /jsonbin/{book_id}` - Получить книгу по ID
- `PUT /jsonbin/{book_id}` - Обновить книгу
- `DELETE /jsonbin/{book_id}` - Удалить книгу

## Структура проекта

```
library_catalog/
├── app/
│   ├── crud/          # CRUD операции для разных хранилищ
│   ├── database.py    # Настройки базы данных
│   ├── integrations/  # Интеграции с внешними API
│   ├── interface/     # Абстрактные классы и интерфейсы
│   ├── models/        # Модели SQLAlchemy
│   ├── schemas/       # Pydantic схемы
│   ├── routes/        # Маршруты API
│   └── main.py        # Основной файл приложения
├── .env               # Пример файла окружения
├── requirements.txt   # Зависимости
└── README.md          # Документация
```

### Ответы на вопросы

#### 1. Проблемы хранения данных в оперативной памяти

**Недостатки:**
- **Ограниченный объем:** Зависит от размера RAM, что может стать проблемой для больших объемов данных.
- **Проблемы с масштабированием:** Не подходит для долгосрочного хранения или работы с большими массивами данных.
- **Отсутствие структуры:** Нет встроенных механизмов для сложных запросов, индексации или отношений между данными.
- **Безопасность:** Уязвимость к атакам (например, инъекциям кода) из-за прямого доступа к памяти.

**Пример:** Хранение сессий пользователей в памяти — при перезапуске сервера все сессии теряются.

---

### 2. Преимущества и недостатки файлового хранения

**Преимущества:**
- **Простота:** Легко реализовать (например, JSON/CSV-файлы).
- **Переносимость:** Файлы можно копировать, переносить между системами.
- **Долговременность:** Данные сохраняются после перезагрузки.
- **Гибкость:** Подходит для небольших проектов или конфигураций.

**Недостатки:**
- **Производительность:** Медленный доступ при больших объемах данных (линейный поиск).
- **Отсутствие транзакций:** Нет ACID-гарантий (атомарность, согласованность и т.д.).
- **Проблемы с параллелизмом:** Конфликты при одновременной записи.
- **Сложность масштабирования:** Ручная реализация индексов или отношений между данными.
- **Безопасность:** Уязвимость к повреждению файлов.

**Пример:** Хранение настроек приложения в `config.json`.

---

### 3. Сравнительный анализ способов хранения данных

| Критерий               | Оперативная память       | Файлы (JSON/CSV)         | Базы данных (PostgreSQL) |
|------------------------|--------------------------|--------------------------|--------------------------|
| **Скорость доступа**   | Очень высокая            | Низкая (для больших данных) | Высокая (с индексами) |
| **Постоянность**       | Нет (данные теряются)    | Да                       | Да                       |
| **Масштабируемость**   | Плохая                   | Ограниченная             | Отличная                 |
| **Сложность запросов** | Ручная реализация        | Ручная реализация        | Поддержка SQL, JOIN      |
| **Транзакции**         | Нет                      | Нет                      | ACID-гарантии            |
| **Параллельный доступ**| Проблемы (блокировки)    | Проблемы                 | Оптимизирован            |
| **Безопасность**       | Низкая                   | Средняя                  | Высокая (роли, шифрование) |
| **Использование**      | Кэш, сессии             | Конфиги, небольшие данные | Проекты любого масштаба |

**Примеры:**
- **Оперативная память:** Кэширование результатов API-запросов.
- **Файлы:** Локальное хранилище для мобильного приложения.
- **Базы данных:** Интернет-магазин с тысячами товаров и заказов.

---

### Итог:
- **Оперативная память** — для временных данных, где важна скорость.
- **Файлы** — для простых задач с небольшим объемом данных.
- **Базы данных** — для сложных проектов с требованиями к надежности и масштабируемости.